summary(lm(count ~
I(1 * (spray == 'B')) + I(1 * (spray == 'C')) +
I(1 * (spray == 'D')) + I(1 * (spray == 'E')) +
I(1 * (spray == 'F'))),
data = InsectSprays))$coef
## Hard coding the dummy variables manually
# Ao omitir spray == 'A', estou dizendo que essa é minha referência
summary(lm(count ~
I(1 * (spray == 'B')) + I(1 * (spray == 'C')) +
I(1 * (spray == 'D')) + I(1 * (spray == 'E')) +
I(1 * (spray == 'F'))),
data = InsectSprays)$coef
## Hard coding the dummy variables manually
# Ao omitir spray == 'A', estou dizendo que essa é minha referência
summary(lm(count ~
I(1 * (spray == 'B')) + I(1 * (spray == 'C')) +
I(1 * (spray == 'D')) + I(1 * (spray == 'E')) +
I(1 * (spray == 'F')),
data = InsectSprays))$coef
summary(lm(count ~
I(1 * (spray == 'B')) + I(1 * (spray == 'C')) +
I(1 * (spray == 'D')) + I(1 * (spray == 'E')) +
I(1 * (spray == 'F')) + I(1 * (spray == 'A')),
data = InsectSprays))$coef
#Com 6 médias é impossível tentar dar fit em 7 parâmetros
summary(lm(count ~
I(1 * (spray == 'B')) + I(1 * (spray == 'C')) +
I(1 * (spray == 'D')) + I(1 * (spray == 'E')) +
I(1 * (spray == 'F')) + I(1 * (spray == 'A')),
data = InsectSprays))$coef
# Remover a intersecção
summary(lm(count ~ spray - 1, data = InsectSprays))$coef
# Removendo a intersecção, ele não considera nenhum como referência (que seria o primeiro nível do fator spray)
levels(InsectSprays$spray)
str(InsectSprays$spray)
summary(lm(count ~ spray - 1, data = InsectSprays))$coef
#O resultado é igual a média
mean(InsectSprays$spray)
#O resultado é igual a média
mean(InsectSprays$spray)
#O resultado é igual a média
summarise(group_by(InsectSprays, spray), mn = mean(count))
#O resultado é igual a média
summarise(group_by(InsectSprays, spray), mean = mean(count))
summary(lm(count ~ spray, data = InsectSprays))$coef
# With relevel
spray2 = relevel(InsectSprays$spray, "C")
spray2
summary(lm(count ~ spray2, data = InsectSprays))$coef
setwd('C:/GD/DS/Lefort/Segmentacao1e2e3')
data = read.csv('indata/OrdinalQ1Q2Q3.csv', encoding = 'UTF-8', sep = ',')
names(data)[1] = "Se_SP_haquantosanos"
plot(x = data$Dor_costas_VAS, data$BPI_6_v1)
plot(x = data$Dor_costas_VAS, data$BPI_3_v1)
# Correlações de Pearson --------------------------------------------------
library(corrplot)
#Função para realizar o plot
corr_fun = function(corr, method){
corrplot(corr,
method = method,
type = 'upper',
tl.col = "black",
tl.srt = 45,
title = 'Matrix de correlação de coeficiente de Pearson entre variáveis ordinais
dos questionários Gotemburgo, BPI e Oswestry',
mar = c(0,0,5,0))
}
cormatrix = cor(data,
, use = 'pairwise.complete.obs')
tiff('outputdata/OrdinalQ1Q2Q3_Number.tiff', units = "in", width = 16, height = 16, res = 450)
corr_fun(cormatrix, 'number')
dev.off()
tiff('outputdata/OrdinalQ1Q2Q3_Number.tiff', units = "in", width = 18, height = 18, res = 450)
corr_fun(cormatrix, 'number')
dev.off()
rm(list=ls())
# setwd('C:/Users/vitor/OneDrive - IPT/Lefort/Segmentacao1')
# setwd('C:/Users/vpb/OneDrive - IPT/Lefort/Segmentacao1')
setwd('C:/GD/DS/Lefort/Segmentacao1e2e3')
library(tidyverse)
library(GGally)
library(lattice)
# Objetivo deste código é conseguir visualizar correlações entre as variáveis contínuas, e entre as variáveis
# contínuas e variáveis binárias para as variáveis do questionário 1 e 2
# Juntar as bases de 1 e 2 ------------------------------------------------
data1 = read.csv('indata/Binaria_Ordinal_Q1_Q2.csv', encoding = 'UTF-8', sep = ',')
data1[1] = NULL
data2 = read.csv('indata/Ordinal_Q3.csv', encoding = 'UTF-8', sep = ',')
names(data2)[1] = "Oswestry1_v1"
Binaria_Ordinal_Q1_Q2_Q3 = cbind(data1,data2)
write.csv(Binaria_Ordinal_Q1_Q2_Q3, 'outputdata/Binaria_Ordinal_Q1_Q2_Q3.csv')
# Iniciar a análise com essas variáveis binárias e ordinais ---------------
data = Binaria_Ordinal_Q1_Q2_Q3
# Subset com as variáveis ordinais ----------------------------------------
ordinallist = names(data[c(68:100)])
ordinaldf = subset(x = data, select = ordinallist)
#pairs(ordinaldf)
#splom(ordinaldf)
# Variáveis Binárias ----------------------------------------
bindata = data1[c(1:67)]
#Não há relação de ordinalidade, logo, todos os dados do dataset bindata são
#Se não adicionarmos [], R não mantém a estrutura de fatores
bindata[] = lapply(bindata[], factor)
dfbind = cbind(ordinaldf,bindata)
#write.csv(dfbind,'binaria_e_ordinal.csv')
library(reshape2)
meltdata = melt(data = dfbind, id.vars = names(bindata), measure.vars = names(ordinaldf))
names(meltdata)
#Dor na lombar
ggplot(data = meltdata, aes(D30,value)) +
geom_boxplot(aes(fill = D30)) +
geom_jitter(size = 0.5) +
facet_wrap(.~variable, scales = "free")
# Coeficiente de correlação de ponto bisserial ----------------------------
library(polycor)
polyserial(as.numeric(dfbind$Somatoria_Owestry),dfbind$D30)
# Matriz de correlação  ---------------------------------------------------
rpb = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
xaxis = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
yaxis = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
cont = 1
for (j in 1:length(bindata)){
for (i in 1:length(ordinaldf)){
rpb[cont,] = polyserial(as.numeric(ordinaldf[[i]]), bindata[[j]])
xaxis[cont,] = names(ordinaldf[i])
yaxis[cont,] = names(bindata[j])
cont = cont + 1
}
}
#Aqui finalmente é a matriz de correlação
pbmatrix = data.frame(cbind(yaxis, xaxis, rpb))
names(pbmatrix) = c("Binaria","Ordinal","rpb")
write.csv(pbmatrix, 'outputdata/biseralcorrelation_Q1_Q2_Q3.csv')
#CorrelationMatrix
bindata
corrmatrix = matrix(NA, nrow = length(bindata), ncol = length(ordinaldf))
#Criar matrix
for (j in 1:length(bindata)){
for (i in 1:length(ordinaldf)){
#Preencher a matriz
corrmatrix[j,i] = polyserial(as.numeric(ordinaldf[[i]]), bindata[[j]])
}
}
#Para obter a matrix de correlação
corrdf = data.frame(corrmatrix)
rownames(corrdf) = c(names(bindata))
colnames(corrdf) = names(ordinaldf)
# tiff('outputdata/Binaria_Ordinal_CorrelationMatrix.tiff', units = 'in', width = 12, height = 20, res = 600)
# corrplot(as.matrix(corrdf),
#          tl.srt = 45,
#          tl.col = 'black',
#          title = "Matrix de correlação de ponto bisserial (correlograma) entre as variáveis binárias (linhas)
#          e variáveis ordinais (colunas) para os Questionários Gotemburgo, BPI e Oswestry",
#          mar=c(0,0,3,0))
# dev.off()
tiff('outputdata/Binaria_Ordinal_CorrelationMatrix.tiff', units = 'in', width = 16, height = 24, res = 450)
corrplot(as.matrix(corrdf),
tl.srt = 45,
tl.col = 'black',
title = "Matrix de correlação de ponto bisserial (correlograma) entre as variáveis binárias (linhas)
e variáveis ordinais (colunas) para os Questionários Gotemburgo, BPI e Oswestry",
mar=c(0,0,3,0),
method = 'number')
dev.off()
tiff('outputdata/Binaria_Ordinal_CorrelationMatrix.tiff', units = 'in', width = 12, height = 20, res = 600)
corrplot(as.matrix(corrdf),
tl.srt = 45,
tl.col = 'black',
title = "Matrix de correlação de ponto bisserial (correlograma) entre as variáveis binárias (linhas)
e variáveis ordinais (colunas) para os Questionários Gotemburgo, BPI e Oswestry",
mar=c(0,0,3,0))
dev.off()
tiff('outputdata/Binaria_Ordinal_CorrelationMatrix_Number.tiff', units = 'in', width = 16, height = 24, res = 450)
corrplot(as.matrix(corrdf),
tl.srt = 45,
tl.col = 'black',
title = "Matrix de correlação de ponto bisserial (correlograma) entre as variáveis binárias (linhas)
e variáveis ordinais (colunas) para os Questionários Gotemburgo, BPI e Oswestry",
mar=c(0,0,3,0),
method = 'number')
dev.off()
tiff('outputdata/Binaria_Ordinal_CorrelationMatrix_Number.tiff', units = 'in', width = 20, height = 30, res = 300)
corrplot(as.matrix(corrdf),
tl.srt = 45,
tl.col = 'black',
title = "Matrix de correlação de ponto bisserial (correlograma) entre as variáveis binárias (linhas)
e variáveis ordinais (colunas) para os Questionários Gotemburgo, BPI e Oswestry",
mar=c(0,0,3,0),
method = 'number')
dev.off()
setwd('C:/GD/DS/Lefort/Segmentacao1e2')
library(tidyverse)
dataQ1 = read.csv('Q1bin.csv', encoding = 'UTF-8')
names(dataQ1)[1]= "ID"
dataQ1[1] = NULL #index do python
rm(list=ls())
setwd('C:/GD/DS/Lefort/Segmentacao1e2')
library(tidyverse)
dataQ1 = read.csv('Q1bin.csv', encoding = 'UTF-8')
names(dataQ1)[1]= "ID"
dataQ1[1] = NULL #index do python
dataQ1[1] = NULL
dataQ2_dores = read.csv('dorescorpo.csv', encoding = 'UTF-8')
dataQ2_dores[1] = NULL
data = data.frame(cbind(dataQ1,dataQ2_dores))
names(data)[c(23:67)] = names(dataQ2_dores)
datacorr = data
# Biblioteca que permite executar a correlação tetracórica ou o coeficiente de phi----------------
library(psych)
# Utilizar o coeficiente de phi -------------------------------------------
phimat<-function(x) {
xcol<-dim(x)[2]
newx<-matrix(NA,nrow=xcol,ncol=xcol)
for(i in 1:xcol) {
for(j in 1:xcol) newx[i,j]<-phi(table(x[,i],x[,j]))
}
rownames(newx)<-colnames(newx)<-colnames(x)
return(newx)
}
phimatrix = data.frame(phimat(datacorr))
#Dor na Lombar
costas = data.frame(cbind(names(phimatrix),phimatrix$X30))
names(costas)[1:2] = c('fatores','Dor_Lombar_30')
write.csv(x = costas, file = 'outputdata/Lombar_Costas.csv')
write.csv(x = costas, file = 'outputdata/PHI_Lombar_Costas.csv')
library(gmodels)
freq22 = matrix(NA, nrow = length(datacorr)^2, ncol = 1)
#Matrix nome das variavei
denominador = matrix(NA, nrow = length(datacorr)^2, ncol = 1)
numerador = matrix(NA, nrow = length(datacorr)^2, ncol = 1)
qte_denom = matrix(NA, nrow = length(datacorr)^2, ncol = 2)
nums = matrix(NA, nrow = length(datacorr)^2, ncol = 4)
cont = 1
for (i in 1:length(datacorr)){
for (j in 1: length(datacorr)){
cross = CrossTable(datacorr[[j]],datacorr[[i]], format = "SAS");
freq22[cont,] = cross$prop.row[2,2]
qte_denom[cont,c(1,2)] = c(cross$t[2,1] + cross$t[2,2],cross$t[1,1] + cross$t[1,2])
denominador[cont,] = names(datacorr[j])
numerador[cont,] = names(datacorr[i])
nums[cont,c(1:4)] = c(cross$t[1,1], cross$t[1,2], cross$t[2,1], cross$t[2,2])
cont = cont + 1
}
}
corrmatrix = matrix(NA, nrow = length(datacorr), ncol = length(datacorr))
#Criar matrix
for (i in 1:length(datacorr)){ #Preencher as linhas
for (j in 1:length(datacorr)){ #Preencher as colunas
# A tabela cruzada
cross = CrossTable(datacorr[[j]],datacorr[[i]], format = "SAS");
#A frequência que desejamos coletar
freq22 = cross$prop.row[2,2]
#Preencher a matriz
corrmatrix[i,j] = freq22
}
}
#Para obter a matrix de correlação
corrdf = data.frame(corrmatrix)
rownames(corrdf) = c(names(datacorr))
colnames(corrdf) = names(datacorr)
View(corrdf)
corrdf$Livrar_perda_sens = NULL
tiff('Binarias_Q1_Q2_Number.tiff', units = "in", width = 20, height = 20, res = 400)
corrplot(as.matrix(corrdf),
tl.srt = 45,
tl.col = 'black',
type = 'upper',
method = 'number')
dev.off()
tiff('outputdata/Binarias_Q1_Q2_Number.tiff', units = "in", width = 20, height = 20, res = 400)
corrplot(as.matrix(corrdf),
tl.srt = 45,
tl.col = 'black',
type = 'upper',
method = 'number')
dev.off()
tiff('outputdata/Binarias_Q1_Q2_Number.tiff', units = "in", width = 30, height = 30, res = 300)
corrplot(as.matrix(corrdf),
tl.srt = 45,
tl.col = 'black',
type = 'upper',
method = 'number')
dev.off()
tiff('outputdata/BPI_Corpo_Binarias.tiff', units = "in", width = 20, height = 20, res = 300)
corrplot(as.matrix(corrdf[-c(1:22),-c(1:22)]),
tl.srt = 45,
tl.col = 'black',
type = 'upper',
method = 'number')
dev.off()
# Square -----------------------------------------------------------------
tiff('outputdata/Binarias_Q1_Q2_Square.tiff', units = "in", width = 30, height = 30, res = 300)
corrplot(as.matrix(corrdf),
tl.srt = 45,
tl.col = 'black',
type = 'upper',
method = 'square')
dev.off()
tiff('outputdata/BPI_Corpo_Binarias_Square.tiff', units = "in", width = 20, height = 20, res = 300)
corrplot(as.matrix(corrdf[-c(1:22),-c(1:22)]),
tl.srt = 45,
tl.col = 'black',
type = 'upper',
method = 'square')
dev.off()
# Square -----------------------------------------------------------------
tiff('outputdata/Binarias_Q1_Q2_Circle.tiff', units = "in", width = 30, height = 30, res = 300)
corrplot(as.matrix(corrdf),
tl.srt = 45,
tl.col = 'black',
type = 'upper',
method = 'circle')
dev.off()
tiff('outputdata/BPI_Corpo_Binarias_Circle.tiff', units = "in", width = 20, height = 20, res = 300)
corrplot(as.matrix(corrdf[-c(1:22),-c(1:22)]),
tl.srt = 45,
tl.col = 'black',
type = 'upper',
method = 'cirle')
dev.off()
# setwd('C:/Users/vitor/OneDrive - IPT/Lefort/Segmentacao1')
# setwd('C:/Users/vpb/OneDrive - IPT/Lefort/Segmentacao1')
setwd('C:/GD/DS/Lefort/Segmentacao1e2')
library(tidyverse)
dataQ1 = read.csv('Q1bin.csv', encoding = 'UTF-8')
names(dataQ1)[1]= "ID"
# setwd('C:/Users/vitor/OneDrive - IPT/Lefort/Segmentacao1')
# setwd('C:/Users/vpb/OneDrive - IPT/Lefort/Segmentacao1')
setwd('C:/GD/DS/Lefort/Segmentacao1e2')
library(tidyverse)
dataQ1 = read.csv('Q1bin.csv', encoding = 'UTF-8')
names(dataQ1)[1]= "ID"
dataQ1[1] = NULL #index do python
dataQ1[1] = NULL
dataQ2_dores = read.csv('dorescorpo.csv', encoding = 'UTF-8')
dataQ2_dores[1] = NULL
data = data.frame(cbind(dataQ1,dataQ2_dores))
names(data)[c(23:67)] = names(dataQ2_dores)
datacorr = data
# Biblioteca que permite executar a correlação tetracórica ou o coeficiente de phi----------------
library(psych)
# Utilizar o coeficiente de phi -------------------------------------------
phimat<-function(x) {
xcol<-dim(x)[2]
newx<-matrix(NA,nrow=xcol,ncol=xcol)
for(i in 1:xcol) {
for(j in 1:xcol) newx[i,j]<-phi(table(x[,i],x[,j]))
}
rownames(newx)<-colnames(newx)<-colnames(x)
return(newx)
}
phimatrix = data.frame(phimat(datacorr))
#Dor na Lombar
costas = data.frame(cbind(names(phimatrix),phimatrix$X30))
names(costas)[1:2] = c('fatores','Dor_Lombar_30')
write.csv(x = costas, file = 'outputdata/PHI_Lombar_Costas.csv')
library(gmodels)
freq22 = matrix(NA, nrow = length(datacorr)^2, ncol = 1)
#Matrix nome das variavei
denominador = matrix(NA, nrow = length(datacorr)^2, ncol = 1)
numerador = matrix(NA, nrow = length(datacorr)^2, ncol = 1)
qte_denom = matrix(NA, nrow = length(datacorr)^2, ncol = 2)
nums = matrix(NA, nrow = length(datacorr)^2, ncol = 4)
cont = 1
for (i in 1:length(datacorr)){
for (j in 1: length(datacorr)){
cross = CrossTable(datacorr[[j]],datacorr[[i]], format = "SAS");
freq22[cont,] = cross$prop.row[2,2]
qte_denom[cont,c(1,2)] = c(cross$t[2,1] + cross$t[2,2],cross$t[1,1] + cross$t[1,2])
denominador[cont,] = names(datacorr[j])
numerador[cont,] = names(datacorr[i])
nums[cont,c(1:4)] = c(cross$t[1,1], cross$t[1,2], cross$t[2,1], cross$t[2,2])
cont = cont + 1
}
}
crosstable = data.frame(cbind(denominador, numerador, freq22, qte_denom, nums))
View(crosstable)
names(crosstable) = c("demonimador", "numerador", "Frequência","Qtd_1_Denom", "Qtd_0_Demon",
"D0N0",'D0N1','D1N0','D1N1')
write.csv(x = crosstable, file = 'outputdata/Crosstable_Q1_Q2.csv')
#Para inspecionar
library(gmodels)
a = CrossTable(datacorr$Dor_pernas,datacorr$Livrar_costas, format = "SAS")
CrossTable(datacorr$Dor_pernas,datacorr$Livrar_perna, format = "SAS")
corrmatrix = matrix(NA, nrow = length(datacorr), ncol = length(datacorr))
corrmatrix = matrix(NA, nrow = length(datacorr), ncol = length(datacorr))
#Criar matrix
for (i in 1:length(datacorr)){ #Preencher as linhas
for (j in 1:length(datacorr)){ #Preencher as colunas
# A tabela cruzada
cross = CrossTable(datacorr[[j]],datacorr[[i]], format = "SAS");
#A frequência que desejamos coletar
freq22 = cross$prop.row[2,2]
#Preencher a matriz
corrmatrix[i,j] = freq22
}
}
View(corrmatrix)
#Para obter a matrix de correlação
corrdf = data.frame(corrmatrix)
rownames(corrdf) = c(names(datacorr))
colnames(corrdf) = names(datacorr)
# Number -----------------------------------------------------------------
tiff('outputdata/Binarias_Q1_Q2_Number.tiff', units = "in", width = 30, height = 30, res = 300)
corrplot(as.matrix(corrdf),
tl.srt = 45,
tl.col = 'black',
type = 'upper',
method = 'number')
dev.off()
View(corrdf)
# DataViz -----------------------------------------------------------------
rm(list=ls())
# setwd('C:/Users/vitor/OneDrive - IPT/Lefort/Segmentacao1')
# setwd('C:/Users/vpb/OneDrive - IPT/Lefort/Segmentacao1')
setwd('C:/GD/DS/Lefort/Segmentacao1e2')
library(tidyverse)
dataQ1 = read.csv('Q1bin.csv', encoding = 'UTF-8')
names(dataQ1)[1]= "ID"
dataQ1[1] = NULL #index do python
dataQ1[1] = NULL
dataQ2_dores = read.csv('dorescorpo.csv', encoding = 'UTF-8')
dataQ2_dores[1] = NULL
data = data.frame(cbind(dataQ1,dataQ2_dores))
names(data)[c(23:67)] = names(dataQ2_dores)
datacorr = data
View(datacorr)
corrmatrix = matrix(NA, nrow = length(datacorr), ncol = length(datacorr))
#Para inspecionar
library(gmodels)
CrossTable(datacorr$Dor_pernas,datacorr$Livrar_perna, format = "SAS")
a = CrossTable(datacorr$Dor_pernas,datacorr$Livrar_perna, format = "SAS")
freq_ = a$prop.row[2,2]
a$prop.row[2,2]
# DataViz -----------------------------------------------------------------
rm(list=ls())
# setwd('C:/Users/vitor/OneDrive - IPT/Lefort/Segmentacao1')
# setwd('C:/Users/vpb/OneDrive - IPT/Lefort/Segmentacao1')
setwd('C:/GD/DS/Lefort/Segmentacao1e2')
library(tidyverse)
dataQ1 = read.csv('Q1bin.csv', encoding = 'UTF-8')
names(dataQ1)[1]= "ID"
dataQ1[1] = NULL #index do python
dataQ1[1] = NULL
dataQ2_dores = read.csv('dorescorpo.csv', encoding = 'UTF-8')
dataQ2_dores[1] = NULL
data = data.frame(cbind(dataQ1,dataQ2_dores))
names(data)[c(23:67)] = names(dataQ2_dores)
datacorr = data
corrmatrix = matrix(NA, nrow = length(datacorr), ncol = length(datacorr))
corrmatrix = matrix(NA, nrow = length(datacorr), ncol = length(datacorr))
#Criar matrix
for (i in 1:length(datacorr)){ #Preencher as linhas
for (j in 1:length(datacorr)){ #Preencher as colunas
# A tabela cruzada
cross = CrossTable(datacorr[[i]],datacorr[[j]], format = "SAS");
#A frequência que desejamos coletar
freq22 = cross$prop.row[2,2]
#Preencher a matriz
corrmatrix[i,j] = freq22
}
}
#Para obter a matrix de correlação
corrdf = data.frame(corrmatrix)
View(corrdf)
rownames(corrdf) = c(names(datacorr))
colnames(corrdf) = names(datacorr)
# Number -----------------------------------------------------------------
tiff('outputdata/Binarias_Q1_Q2_Number.tiff', units = "in", width = 30, height = 30, res = 300)
corrplot(as.matrix(corrdf),
tl.srt = 45,
tl.col = 'black',
type = 'upper',
method = 'number')
dev.off()
# Number -----------------------------------------------------------------
tiff('outputdata/Binarias_Q1_Q2_Number.tiff', units = "in", width = 30, height = 30, res = 300)
corrplot(as.matrix(corrdf),
tl.srt = 45,
tl.col = 'black',
type = 'upper',
method = 'number')
dev.off()
tiff('outputdata/BPI_Corpo_Binarias_Number.tiff', units = "in", width = 20, height = 20, res = 300)
corrplot(as.matrix(corrdf[-c(1:22),-c(1:22)]),
tl.srt = 45,
tl.col = 'black',
type = 'upper',
method = 'number')
dev.off()
# Square -----------------------------------------------------------------
tiff('outputdata/Binarias_Q1_Q2_Circle.tiff', units = "in", width = 30, height = 30, res = 300)
corrplot(as.matrix(corrdf),
tl.srt = 45,
tl.col = 'black',
type = 'upper',
method = 'circle')
dev.off()
tiff('outputdata/BPI_Corpo_Binarias_Circle.tiff', units = "in", width = 20, height = 20, res = 300)
corrplot(as.matrix(corrdf[-c(1:22),-c(1:22)]),
tl.srt = 45,
tl.col = 'black',
type = 'upper',
method = 'cirle')
dev.off()
tiff('outputdata/BPI_Corpo_Binarias_Circle.tiff', units = "in", width = 20, height = 20, res = 300)
corrplot(as.matrix(corrdf[-c(1:22),-c(1:22)]),
tl.srt = 45,
tl.col = 'black',
type = 'upper',
method = 'circle')
dev.off()
