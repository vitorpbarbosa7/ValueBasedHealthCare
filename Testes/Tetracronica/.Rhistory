sigma = sqrt(sigmasquared)
#Sum of Squares of X
ssx = sum((x - mean(x))^2)
#Valor que segue a distribuição t de student para o teste de hipótese
H_nula_Beta1 = 0
varBeta1 = sigmasquared/ssx
#Stardard Error Beta1
se_Beta1 = sqrt(varBeta1)
t_calculado = (Beta1 - H_nula_Beta1)/se_Beta1
pBeta1 = 2*pt(abs(t_calculado), df = n-2, lower.tail = FALSE)
pBeta1
#Desvio padrão médio dos resíduos
sigma = sqrt(sigmasquared)
sigma
# Questão 3 ---------------------------------------------------------------
mtcars = mtcars
fit = lm(mpg ~ wt, data = mtcars)
x = mtcars$wt
y = mtcars$mpg
prediction_interval = data.frame(predict(fit, newdata = newx, interval = ("prediction")))
newx = data.frame(x = mean(x))
names(newx)[1] = "wt"
predict(fit, newdata = newx, interval = ("confidence"))
# Questão 3 ---------------------------------------------------------------
mtcars = mtcars
fit = lm(mpg ~ wt, data = mtcars)
x = mtcars$wt
y = mtcars$mpg
prediction_interval = data.frame(predict(fit, newdata = newx, interval = ("prediction")))
newx = data.frame(x = mean(x))
names(newx)[1] = "wt"
predict(fit, newdata = newx, interval = ("confidence"))
# 5
newx = data.frame(x = 3)
names(newx)[1] = "wt"
predict(fit, newdata = newx, interval = ("prediction"))
library(tidyverse)
g = ggplot(mtcars, aes(x = wt, y = mpg)) +
geom_point() +
geom_smooth(method = "lm", colour = "black")
g
# 5
newx = data.frame(x = 3)
names(newx)[1] = "wt"
predict(fit, newdata = newx, interval = ("prediction"))
#6
fit = lm(mpg ~ I(wt/2), mtcars)
newx = data.frame(x = 3)
names(newx)[1] = "wt"
predict(fit, newdata = newx, interval = ("confidence"))
confint(fit)
#9
x = mtcars$wt
y = mtcars$mpg
Beta1 = cor(x,y)*sd(y)/sd(x)
Beta0 = mean(y) - Beta1*mean(x)
#Residuos
e = y - Beta0 - Beta1*x
#Residuos não explicados pelo modelo
SSnoex = sum(e^2)
#Residuos totais
SStot = sum((y - mean(y))^2)
#Razão entre os dois
SSnoex/SStot
x <- c(0.61, 0.93, 0.83, 0.35, 0.54, 0.16, 0.91, 0.62, 0.62)
y <- c(0.67, 0.84, 0.6, 0.18, 0.85, 0.47, 1.1, 0.65, 0.36)
n = length(x)
Beta1 = cor(x,y)*sd(y)/sd(x)
Beta0 = mean(y) - Beta1*mean(x)
#Residuos
e = y - Beta0 - Beta1*x
#Média dos resíduos ao quadrado (Média porque divide por -2)
sigmasquared = sum((e^2)/(n-2))
#Desvio padrão médio dos resíduos
sigma = sqrt(sigmasquared)
#Sum of Squares of X
ssx = sum((x - mean(x))^2)
#Valor que segue a distribuição t de student para o teste de hipótese
H_nula_Beta1 = 0
varBeta1 = sigmasquared/ssx
#Stardard Error Beta1
se_Beta1 = sqrt(varBeta1)
t_calculado = (Beta1 - H_nula_Beta1)/se_Beta1
pBeta1 = 2*pt(abs(t_calculado), df = n-2, lower.tail = FALSE)
# Questão 3 ---------------------------------------------------------------
mtcars = mtcars
sigma
# Questão 3 ---------------------------------------------------------------
mtcars = mtcars
fit = lm(mpg ~ wt, data = mtcars)
x = mtcars$wt
y = mtcars$mpg
prediction_interval = data.frame(predict(fit, newdata = newx, interval = ("prediction")))
newx = data.frame(x = mean(x))
names(newx)[1] = "wt"
predict(fit, newdata = newx, interval = ("confidence"))
# 5
newx = data.frame(x = 3)
names(newx)[1] = "wt"
predict(fit, newdata = newx, interval = ("prediction"))
library(tidyverse)
g = ggplot(mtcars, aes(x = wt, y = mpg)) +
geom_point() +
geom_smooth(method = "lm", colour = "black")
predict(fit, newdata = newx, interval = ("prediction"))
#6
fit = lm(mpg ~ I(wt/2), mtcars)
newx = data.frame(x = 3)
names(newx)[1] = "wt"
predict(fit, newdata = newx, interval = ("confidence"))
confint(fit)
x = rnorm(n);
x2 = rnorm(n);
x3 = rnorm(n)
# Geração dos dados
n = 100;
x = rnorm(n);
x2 = rnorm(n);
x3 = rnorm(n)
#Variável y
y = 1 + x + x2 + x3 + rnorm(n, sd = 0.1)
#Resíduo de y ao desconsiderar x1 e x2
ey = resid(lm(y ~ x2 + x3))
ey
ex = resid(lm(x ~ x2 + x3))
plot(ex)
plot(ey)
#Regressão pela origem:
sum(ey*ex)/sum(ex^2)
# Geração dos dados
n = 100;
# Criação de 3 distribuições normais
x = rnorm(n);
x2 = rnorm(n);
x3 = rnorm(n);
#Variável y
y = 1 + x + x2 + x3 + rnorm(n, sd = 0.1)
#Resíduo de y ao desconsiderar x1 e x2
ey = resid(lm(y ~ x2 + x3))
ex = resid(lm(x ~ x2 + x3))
#Regressão pela origem:
sum(ey*ex)/sum(ex^2)
#Por lm:
coef(lm(ey ~ ex - 1))
#No geral:
coef(lm(y ~ x + x2 + x3))
require(datasets)
data(swiss)
?swiss
head(swiss)
#São poucos dados
library(tidyverse)
#Addon tools for ggplot
library(GGally)
g = ggpairs(swiss, lower = list(continous = "smooth"),
params = c(method = "loess"))
#Addon tools for ggplot
library(GGally)
g = ggpairs(swiss, lower = list(continous = "smooth"),
params = c(method = "loess"))
g = ggpairs(swiss, lower = list(continous = "smooth"),
wrap = c(method = "loess"))
g = ggpairs(swiss, lower = list(continous = "smooth"))
g
my_fn <- function(data, mapping, ...){
p <- ggplot(data = data, mapping = mapping) +
geom_point() +
geom_smooth(method=loess, fill="red", color="red", ...) +
geom_smooth(method=lm, fill="blue", color="blue", ...)
p
}
g = ggpairs(swiss,columns = 1:4, lower = list(continuous = my_fn))
g
g = ggpairs(swiss,columns = 1:7, lower = list(continuous = my_fn))
g
g = ggpairs(swiss, lower = list(continuous = my_fn))
g
p <- ggplot(data = data, mapping = mapping) +
geom_point() +
geom_smooth(method=loess, fill="red", color="red", ...) +
#geom_smooth(method=lm, fill="blue", color="blue", ...)
p
my_fn <- function(data, mapping, ...){
p <- ggplot(data = data, mapping = mapping) +
geom_point() +
geom_smooth(method=loess, fill="red", color="red", ...) +
#geom_smooth(method=lm, fill="blue", color="blue", ...)
p
}
g = ggpairs(swiss, lower = list(continuous = my_fn))
g
p <- ggplot(data = data, mapping = mapping) +
geom_point() +
geom_smooth(method=loess, fill="red", color="red", ...)
#geom_smooth(method=lm, fill="blue", color="blue", ...)
p
my_fn <- function(data, mapping, ...){
p <- ggplot(data = data, mapping = mapping) +
geom_point() +
geom_smooth(method=loess, fill="red", color="red", ...)
#geom_smooth(method=lm, fill="blue", color="blue", ...)
p
}
g = ggpairs(swiss, lower = list(continuous = my_fn))
g
# Com todas variáveis:
summary(lm(Fertility ~ ., data = swiss))$coefficients
# Com todas variáveis:
summary(lm(Fertility ~ ., data = swiss))$coefficients
a = (-0.1721140 - 0)/0.07030392
a
2*qt(abs(a), df = length(swiss$Fertility))
2*qt(abs(a), df = length(swiss$Fertility), lower.tail = FALSE)
2*qt(abs(a), df = length(swiss$Fertility)-7, lower.tail = FALSE)
2*pt(abs(a), df = length(swiss$Fertility)-ncol(swiss), lower.tail = FALSE)
length(swiss$Fertility) - ncol(swiss)
2*pt(abs(a), df = length(swiss$Fertility)-ncol(swiss), lower.tail = FALSE)
# Com todas variáveis:
summary(lm(Fertility ~ ., data = swiss))$coefficients
# Com todas variáveis:
coeftable = summary(lm(Fertility ~ ., data = swiss))$coefficients
coeftable
View(coeftable)
#Teste de hipótese para o primeiro coeficiente
tcalc_Beta1 = (coeftable[2,1] - 0)/coeftable[2,2]
pBeta1 = 2*qt(abs(tcalc_Beta1, df = length(swiss$Agriculture)-ncol(swiss)), lower.tail = FALSE)
pBeta1 = 2*qt(abs(tcalc_Beta1), df = length(swiss$Agriculture)-ncol(swiss), lower.tail = FALSE)
#Teste de hipótese para o primeiro coeficiente
tcalc_Beta1 = (coeftable[2,1] - 0)/coeftable[2,2]
pBeta1 = 2*qt(abs(tcalc_Beta1), df = length(swiss$Agriculture)-ncol(swiss), lower.tail = FALSE)
#Teste de hipótese para o primeiro coeficiente
tcalc_Beta1 = (coeftable[2,1] - 0)/coeftable[2,2]
tcalc_Beta1
pBeta1 = 2*pt(abs(tcalc_Beta1), df = length(swiss$Agriculture)-ncol(swiss), lower.tail = FALSE)
pBeta1
coeftable
# Com 1 variável apenas ---------------------------------------------------
summary(lm(Fertility ~ Agriculture, data = swiss))$coefficients
colnames(swiss)
ey = resid(lm(Fertility ~ Examination + Education + Catholic + Infant.Mortality))
ey = resid(lm(Fertility ~ Examination + Education + Catholic + Infant.Mortality, data = swiss))
ex = resid(lm(Agriculture ~ Examination + Education + Catholic + Infant.Mortality, data = swiss))
sum(ey*ex)/sum(ex^2)
# Com 1 variável apenas ---------------------------------------------------
summary(lm(Fertility ~ Agriculture, data = swiss))$coefficients
p <- ggplot(data = data, mapping = mapping) +
geom_point() +
geom_smooth(method=loess, fill="red", color="red", ...)
#geom_smooth(method=lm, fill="blue", color="blue", ...)
p
my_fn <- function(data, mapping, ...){
p <- ggplot(data = data, mapping = mapping) +
geom_point() +
geom_smooth(method=loess, fill="red", color="red", ...)
#geom_smooth(method=lm, fill="blue", color="blue", ...)
p
}
g = ggpairs(swiss, lower = list(continuous = my_fn))
g
# Simulation  -------------------------------------------------------------
n  = 100
x2 = 1:n
x2
x1 = .01*x2 + runif(n, -.1, .1);
x1
plot(x)
plot(x1)
?runif
y = -x1, + x2 + rnorm(n, sd = .01) #Happiness
# Simulation  -------------------------------------------------------------
n  = 100
# Simulation  -------------------------------------------------------------
n  = 100
x2 = 1:n #Time
x1 = .01*x2 + runif(n, -.1, .1); #Money
y = -x1 + x2 + rnorm(n, sd = .01) #Happiness
plot(y,x)
ggplot(data.frame(x = x1, y = y)) + geom_point()
ggplot(data.frame(x = x1, y = y), aes(x = x1, y = y)) + geom_point()
# Simulation  -------------------------------------------------------------
n  = 100
x2 = 1:n #Time
x1 = .01*x2 + runif(n, -.1, .1); #Money
y = -x1 + x2 + rnorm(n, sd = .01) #Happiness
y = -x1 + x2 + rnorm(n, sd = .01) #Happiness
ggplot(data.frame(x = x1, y = y)) + geom_point()
ggplot(data.frame(x = x1, y = y), aes(x = x1, y = y)) + geom_point()
?data.frame
data = data.frame(x = c(x1,x2), y = y)
data
data = data.frame(x = rbind(x1,x2), y = y)
data = data.frame("x1" = x1, "x2" = x2, "y" = y)
data
g = ggpairs(data, lower = list(continuous = my_fn))
g
# Voltando ao modelo criado
summary(lm(y ~ x1 + x2))$coef
# Plots  ------------------------------------------------------------------
g = ggplot(data, aes(y = y, x = x1, colour = x2)) +
geom_point(colour = "grey50", size = 5) +
geom_smooth(method = lm, se = FALSE, colour = "black")
g
# Plots  ------------------------------------------------------------------
g = ggplot(data, aes(y = y, x = x1, colour = x2)) +
geom_point(colour = "grey50", size = 5)
#geom_smooth(method = lm, se = FALSE, colour = "black")
g
# Plots  ------------------------------------------------------------------
g = ggplot(data, aes(y = y, x = x1)) +
geom_point(colour = x2, size = 5)
#geom_smooth(method = lm, se = FALSE, colour = "black")
g
# Plots  ------------------------------------------------------------------
g = ggplot(data, aes(y = y, x = x1, colour = x2)) +
geom_point(colour = "grey50", size = 5)
#geom_smooth(method = lm, se = FALSE, colour = "black")
g
geom_smooth(method = lm, se = FALSE, colour = "black")
g
geom_point(colour = as.numeric(x2), size = 5)
#geom_smooth(method = lm, se = FALSE, colour = "black")
g
# Plots  ------------------------------------------------------------------
g = ggplot(data, aes(y = y, x = x1)) +
geom_point(colour = as.numeric(x2), size = 5)
#geom_smooth(method = lm, se = FALSE, colour = "black")
g
# Plots  ------------------------------------------------------------------
g = ggplot(data, aes(y = y, x = x1)) +
geom_point(fill = as.numeric(x2), size = 5)
#geom_smooth(method = lm, se = FALSE, colour = "black")
g
# Plots  ------------------------------------------------------------------
g = ggplot(data, aes(y = y, x = x1)) +
geom_point(fill = as.numeric(x2), size = 5) +
scale_fill_gradient2(low = "green", mid = "blue", high = "red")
#geom_smooth(method = lm, se = FALSE, colour = "black")
g
# Plots  ------------------------------------------------------------------
g = ggplot(data, aes(y = y, x = x1)) +
geom_point(colour = x2, size = 5) +
scale_colour_gradient2(low = "green", mid = "blue", high = "red")
#geom_smooth(method = lm, se = FALSE, colour = "black")
g
# Plots  ------------------------------------------------------------------
g = ggplot(data, aes(y = y, x = x1)) +
geom_point(colour = x2, size = 5) +
scale_colour_gradient2(low = "green", mid = "blue", high = "red", midpoint = mean(data$x2))
#geom_smooth(method = lm, se = FALSE, colour = "black")
g
# Plots  ------------------------------------------------------------------
g = ggplot(data, aes(y = y, x = x1)) +
geom_point(colour = x2, size = 2) +
scale_colour_gradient2(low = "green", mid = "blue", high = "red", midpoint = mean(data$x2))
#geom_smooth(method = lm, se = FALSE, colour = "black")
g
# Plots  ------------------------------------------------------------------
g = ggplot(data, aes(y = y, x = x1)) +
geom_point(aes(colour = x2), size = 2) +
scale_colour_gradient2(low = "green", mid = "blue", high = "red", midpoint = mean(data$x2))
#geom_smooth(method = lm, se = FALSE, colour = "black")
g
# Plots  ------------------------------------------------------------------
g = ggplot(data, aes(y = y, x = x1)) +
geom_point(aes(colour = x2), size = 2) +
#scale_colour_gradient2(low = "green", mid = "blue", high = "red", midpoint = mean(data$x2))
#geom_smooth(method = lm, se = FALSE, colour = "black")
g
# Plots  ------------------------------------------------------------------
g = ggplot(data, aes(y = y, x = x1)) +
geom_point(aes(colour = x2), size = 2)
#scale_colour_gradient2(low = "green", mid = "blue", high = "red", midpoint = mean(data$x2))
#geom_smooth(method = lm, se = FALSE, colour = "black")
g
# Plots  ------------------------------------------------------------------
g = ggplot(data, aes(y = y, x = x1)) +
geom_point(aes(colour = x2), size = 2) +
scale_colour_gradient2(low = "green", mid = "blue", high = "red", midpoint = mean(data$x2))
#geom_smooth(method = lm, se = FALSE, colour = "black")
g
# Plots  ------------------------------------------------------------------
g = ggplot(data, aes(y = y, x = x1)) +
geom_point(aes(colour = x2), size = 5) +
scale_colour_gradient2(low = "green", mid = "blue", high = "red", midpoint = mean(data$x2))
#geom_smooth(method = lm, se = FALSE, colour = "black")
g
# Plots  ------------------------------------------------------------------
g = ggplot(data, aes(y = y, x = x2)) +
geom_point(aes(colour = x1), size = 5) +
scale_colour_gradient2(low = "green", mid = "blue", high = "red", midpoint = mean(data$x1))
#geom_smooth(method = lm, se = FALSE, colour = "black")
g
# Plots  ------------------------------------------------------------------
g = ggplot(data, aes(y = y, x = x1)) +
geom_point(aes(colour = x2), size = 5) +
scale_colour_gradient2(low = "green", mid = "blue", high = "red", midpoint = mean(data$x2))
#geom_smooth(method = lm, se = FALSE, colour = "black")
g
#Criando residuos (retirando o efeito de x2 para ver a correlação negativa com x1)
data$ey = resid(lm(y ~ x2))
#Criando residuos (retirando o efeito de x2 para ver a correlação negativa com x1)
#x2 que dava a correlação positiva, então estou retirando ela
data$ey = resid(lm(y ~ x2))
data$ex1 = resid(lm(x1 ~ x2))
ggplot(data, aes(x = ex1, y = ey)) +
geom_point()
# O que acontece se adicionarmos variáveis linearmente dependentes --------
z = swiss$Agriculture + swiss$Education
# O que acontece se adicionarmos variáveis linearmente dependentes --------
z = swiss$Agriculture + swiss$Education
lm(Fertility ~ . + z, data = swiss)
ggpairs(data, lower = list(continuous = my_fn))
require(datasets)
data("InsectSprays")
require(datasets)
data("InsectSprays")
?InspectSprays
require(datasets)
data("InsectSprays")
?InsectSprays
InsectSprays
library(tidyverse)
g = ggplot(data = InsectSprays,
aes( y = count, x = spray, fill  = spray)) +
geom_violin(colour = "black", size = 2) +
xlab("Type of spray") + ylab("Insect count")
g
?InsectSprays
g
g = ggplot(data = InsectSprays,
aes( y = count, x = spray, fill  = spray)) +
geom_boxplot() +
xlab("Type of spray") + ylab("Insect count")
g
sample(InsectSprays)
sample(InsectSprays, 5)
# Fit linear model  -------------------------------------------------------
summary(lm(count ~ spray, data = InsectSprays))$coef
# Fit linear model  -------------------------------------------------------
summary(lm(count ~ spray, data = InsectSprays))$coef
,data = InsectSprays))$coef
,data = InsectSprays))$coef
## Hard coding the dummy variables manually
# Ao omitir spray == 'A', estou dizendo que essa é minha referência
summary(lm(count ~
I(1 * (spray == 'B')) + I(1 * (spray == 'C')) +
I(1 * (spray == 'D')) + I(1 * (spray == 'E')) +
I(1 * (spray == 'F'))),
data = InsectSprays))$coef
## Hard coding the dummy variables manually
# Ao omitir spray == 'A', estou dizendo que essa é minha referência
summary(lm(count ~
I(1 * (spray == 'B')) + I(1 * (spray == 'C')) +
I(1 * (spray == 'D')) + I(1 * (spray == 'E')) +
I(1 * (spray == 'F'))),
data = InsectSprays)$coef
## Hard coding the dummy variables manually
# Ao omitir spray == 'A', estou dizendo que essa é minha referência
summary(lm(count ~
I(1 * (spray == 'B')) + I(1 * (spray == 'C')) +
I(1 * (spray == 'D')) + I(1 * (spray == 'E')) +
I(1 * (spray == 'F')),
data = InsectSprays))$coef
summary(lm(count ~
I(1 * (spray == 'B')) + I(1 * (spray == 'C')) +
I(1 * (spray == 'D')) + I(1 * (spray == 'E')) +
I(1 * (spray == 'F')) + I(1 * (spray == 'A')),
data = InsectSprays))$coef
#Com 6 médias é impossível tentar dar fit em 7 parâmetros
summary(lm(count ~
I(1 * (spray == 'B')) + I(1 * (spray == 'C')) +
I(1 * (spray == 'D')) + I(1 * (spray == 'E')) +
I(1 * (spray == 'F')) + I(1 * (spray == 'A')),
data = InsectSprays))$coef
# Remover a intersecção
summary(lm(count ~ spray - 1, data = InsectSprays))$coef
# Removendo a intersecção, ele não considera nenhum como referência (que seria o primeiro nível do fator spray)
levels(InsectSprays$spray)
str(InsectSprays$spray)
summary(lm(count ~ spray - 1, data = InsectSprays))$coef
#O resultado é igual a média
mean(InsectSprays$spray)
#O resultado é igual a média
mean(InsectSprays$spray)
#O resultado é igual a média
summarise(group_by(InsectSprays, spray), mn = mean(count))
#O resultado é igual a média
summarise(group_by(InsectSprays, spray), mean = mean(count))
summary(lm(count ~ spray, data = InsectSprays))$coef
# With relevel
spray2 = relevel(InsectSprays$spray, "C")
spray2
summary(lm(count ~ spray2, data = InsectSprays))$coef
setwd('C:/Users/vitor/OneDrive - IPT/Lefort/Testes/Tetracronica')
library(tidyverse)
data = read.csv('data.csv', encoding = 'UTF-8', sep = ';')
names(data)[1] = "A"
library(psych)
corr = tetrachoric(data)
corrmatrix = data.frame(corr$rho)
# Utilizar o coeficiente de phi -------------------------------------------
phimat<-function(x) {
xcol<-dim(x)[2]
newx<-matrix(NA,nrow=xcol,ncol=xcol)
for(i in 1:xcol) {
for(j in 1:xcol) newx[i,j]<-phi(table(x[,i],x[,j]))
}
rownames(newx)<-colnames(newx)<-colnames(x)
return(newx)
}
phimatrix = data.frame(phimat(data))
View(phimatrix)
