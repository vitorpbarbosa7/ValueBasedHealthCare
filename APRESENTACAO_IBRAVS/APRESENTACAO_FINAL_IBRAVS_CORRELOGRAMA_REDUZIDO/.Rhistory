strip.background =element_rect(fill=NA, colour = NA)) #Cor do background dos títulos de cada face
g = ggplot(Dor_Lombar, aes(x = reorder(Ordinal,rpb) ,y = rpb, fill = rpb)) +
geom_bar(stat = "identity") +
scale_fill_gradient2(
low = 'red', high = 'blue'
) +
geom_text(aes(label = rpb, y = rpb + .05*sign(rpb) ) ) +
coord_flip() +
xlab("Variáveis contínuas ou ordinais") +
ylab("Coeficiente de correlação de ponto bisserial") +
ggtitle("Principais correlações de variáveis de caráter \n ordinal com a dor na lombar") +
theme
tiff('outputdata/imgs/Dor_Lombar_MainCorrelations.tiff', width = 14, height = 10, units = "in", res = 300)
g
dev.off()
listarpb = subset(biserial, (Binaria == 'D30') & (rpb >= +0.45 | rpb <= -0.45))$Ordinal
Binarias = subset(biserial, (Binaria == 'Dor_costas' | Binaria == 'D30' | Binaria == 'Dor_pernas'))
Binarias = subset(Binarias, Ordinal %in% listarpb)
# Para mudar o nome na vertical
labels = c(D30 = "Lombalgia (BPI - 30)", Dor_costas = "Dor nas costas", Dor_pernas = "Dor nas pernas")
g = ggplot(Binarias, aes(x = reorder(Ordinal, rpb), y = rpb, fill = rpb)) +
geom_bar(stat = 'identity') +
scale_fill_gradient2(
low = 'red', high = 'blue'
) +
geom_text(aes(label = rpb, y = rpb + .05*sign(rpb) ) ) +
coord_flip() +
facet_wrap(.~Binaria, labeller = labeller(Binaria = labels)) +
xlab("Variáveis continuas ou ordinais") +
ylab("Coeficiente de correlação de ponto bisserial") +
theme
tiff('outputdata/imgs/Facet_Biseral_Correlation_D30_Costas_Pernas.tiff', width = 15, height = 6, units = "in", res = 150)
g
dev.off()
cruzada = read.csv('outputdata/Crosstable_Got_BPI_RMDQ.csv', sep = ';', encoding = 'UTF-8')
names(cruzada)[4] = 'Frequência'
names(cruzada)[2] = 'Denominador'
cruzada$Frequência = round(cruzada$Frequência, 2)
listafreq = subset(cruzada, Denominador == 'D30' & Frequência >= +0.6)$numerador
Set = subset(cruzada, (Denominador == 'Dor_costas' | Denominador == 'D30' | Denominador == 'Dor_pernas'))
mydata = subset(Set, numerador %in% listafreq)
labels = c(D30 = "Lombalgia (BPI - 30)", Dor_costas = "Dor nas costas", Dor_pernas = "Dor nas pernas")
g = ggplot(mydata, aes(x = reorder(numerador, Frequência), y = Frequência, fill = Frequência)) +
geom_bar(stat = 'identity') +
scale_fill_gradient2(
low = 'yellow', high = 'blue'
) +
geom_text(aes(label = Frequência, y = Frequência + .05*sign(Frequência) ) ) +
coord_flip() +
facet_wrap(.~Denominador, labeller = labeller(Denominador = labels)) +
xlab('Variáveis binárias') +
ylab("Frequência da tabela de contingência") +
theme
tiff('outputdata/imgs/Facet_Contingencia_D30_Costas_Pernas.tiff', width = 10, height = 6, units = "in", res = 150)
rm(list=ls())
# setwd('C:/Users/vitor/OneDrive - IPT/Lefort/Segmentacao1')
# setwd('C:/Users/vpb/OneDrive - IPT/Lefort/Segmentacao1')
setwd('C:/GD/DS/Lefort/Segmentacao1ate5')
library(tidyverse)
library(GGally)
library(lattice)
# Objetivo deste código é conseguir visualizar correlações entre as variáveis cont??nuas, e entre as variáveis
# cont??nuas e variáveis binárias para as variáveis do questionário 1 e 2
# Juntar as bases de de binarios e ordinais ------------------------------------------------
#Todas binárias até o momento
Bin_Gut_BPI_RMDQ = read.csv('indata/Bin_Got_BPI_RMDQ_FILTRADA.csv')
rm(list=ls())
# setwd('C:/Users/vitor/OneDrive - IPT/Lefort/Segmentacao1')
# setwd('C:/Users/vpb/OneDrive - IPT/Lefort/Segmentacao1')
setwd('C:/GD/DS/Lefort/APRESENTACAO_IBRAVS/APRESENTACAO_FINAL_IBRAVS_CORRELOGRAMA_REDUZIDO')
library(tidyverse)
library(GGally)
library(lattice)
# Objetivo deste código é conseguir visualizar correlações entre as variáveis cont??nuas, e entre as variáveis
# cont??nuas e variáveis binárias para as variáveis do questionário 1 e 2
# Juntar as bases de de binarios e ordinais ------------------------------------------------
#Todas binárias até o momento
Bin_Gut_BPI_RMDQ = read.csv('indata/Bin_Got_BPI_RMDQ_FILTRADA.csv')
#Ordinais até RMDQ
Ord_Gut_BPI_Oswestry_RMDQ = read.csv('indata/Ordinal_Q1_Q2_Q3_Q4_FILTRADA.csv', sep = ';')
Ord_Gut_BPI_Oswestry_RMDQ[c(1:2)] = NULL
rm(list=ls())
# setwd('C:/Users/vitor/OneDrive - IPT/Lefort/Segmentacao1')
# setwd('C:/Users/vpb/OneDrive - IPT/Lefort/Segmentacao1')
setwd('C:/GD/DS/Lefort/APRESENTACAO_IBRAVS/APRESENTACAO_FINAL_IBRAVS_CORRELOGRAMA_REDUZIDO')
library(tidyverse)
library(GGally)
library(lattice)
# Objetivo deste código é conseguir visualizar correlações entre as variáveis cont??nuas, e entre as variáveis
# cont??nuas e variáveis binárias para as variáveis do questionário 1 e 2
# Juntar as bases de de binarios e ordinais ------------------------------------------------
#Todas binárias até o momento
Bin_Gut_BPI_RMDQ = read.csv('indata/Bin_Got_BPI_RMDQ_FILTRADA.csv')
#Ordinais até RMDQ
Ord_Gut_BPI_Oswestry_RMDQ = read.csv('indata/Ordinal_Q1_Q2_Q3_Q4_FILTRADA.csv', sep = ';')
Ord_Gut_BPI_Oswestry_RMDQ[c(1:2)] = NULL
#######################################################################################################
###BY PASS EM SF, NÃO PRECISA DESSE QUESTIONÁRIO SÓ PRA PLOTAR O QUE PRECISO PARA A APRESENTAÇÃO
#######################################################################################################
#Salvando todos ordinais até o momento:
Ord_Gut_BPI_Oswestry_RMDQ_SF = Ord_Gut_BPI_Oswestry_RMDQ
# write.csv(Ord_Gut_BPI_Oswestry_RMDQ_SF, 'outputdata/Ordinal_Gut_BPI_Oswestry_RMDQ_SF.csv')
#Binárias e ordinais até o momento
Binaria_Ordinal_Q1_Q2_Q3_Q4_Q5 = data.frame(cbind(Bin_Gut_BPI_RMDQ,Ord_Gut_BPI_Oswestry_RMDQ_SF))
# Subset com as variáveis ordinais ----------------------------------------
ordinallist = names(Ord_Gut_BPI_Oswestry_RMDQ_SF)
ordinaldf = Ord_Gut_BPI_Oswestry_RMDQ_SF
# Variáveis Binárias ----------------------------------------
bindata = Bin_Gut_BPI_RMDQ #(Oswestry e SF não tem binária)
#N?o há relação de ordinalidade, logo, todos os dados do dataset bindata são
#Se N?o adicionarmos [], R N?o mantém a estrutura de fatores
bindata[] = lapply(bindata[], factor)
#Primeira coluna é ind??ce, logo, podemos deletar
bindata[1] = NULL
dfbind = cbind(ordinaldf,bindata)
#write.csv(dfbind,'binaria_e_ordinal.csv')
library(reshape2)
meltdata = melt(data = dfbind, id.vars = names(bindata), measure.vars = names(ordinaldf))
names(meltdata)
write.csv(meltdata, 'outputdata/meltdataboxsplot.csv')
#Dor na lombar
ggplot(data = meltdata, aes(D30,value)) +
geom_boxplot(aes(fill = D30)) +
geom_jitter(size = 0.5) +
facet_wrap(.~variable, scales = "free")
library(polycor)
polyserial(as.numeric(dfbind$Ord_RMDQ),dfbind$D35)
#Matrix de correlação
corrmatrix = matrix(NA, nrow = length(bindata), ncol = length(ordinaldf))
#Criar matrix
for (j in 1:length(bindata)){
for (i in 1:length(ordinaldf)){
#Preencher a matriz
corrmatrix[j,i] = polyserial(as.numeric(ordinaldf[[i]]), bindata[[j]])
}
}
rm(list=ls())
# setwd('C:/Users/vitor/OneDrive - IPT/Lefort/Segmentacao1')
# setwd('C:/Users/vpb/OneDrive - IPT/Lefort/Segmentacao1')
setwd('C:/GD/DS/Lefort/APRESENTACAO_IBRAVS/APRESENTACAO_FINAL_IBRAVS_CORRELOGRAMA_REDUZIDO')
library(tidyverse)
library(GGally)
library(lattice)
# Juntar as bases de de binarios e ordinais ------------------------------------------------
#Todas binárias até o momento
Bin_Gut_BPI_RMDQ = read.csv('indata/Bin_Got_BPI_RMDQ_FILTRADA.csv')
#Ordinais até RMDQ
Ord_Gut_BPI_Oswestry_RMDQ = read.csv('indata/Ordinal_Q1_Q2_Q3_Q4_FILTRADA.csv', sep = ';')
Ord_Gut_BPI_Oswestry_RMDQ[c(1:2)] = NULL
#Salvando todos ordinais até o momento:
Ord_Gut_BPI_Oswestry_RMDQ_SF = Ord_Gut_BPI_Oswestry_RMDQ
#Binárias e ordinais até o momento
Binaria_Ordinal_Q1_Q2_Q3_Q4_Q5 = data.frame(cbind(Bin_Gut_BPI_RMDQ,Ord_Gut_BPI_Oswestry_RMDQ_SF))
# Subset com as variáveis ordinais ----------------------------------------
ordinallist = names(Ord_Gut_BPI_Oswestry_RMDQ_SF)
ordinaldf = Ord_Gut_BPI_Oswestry_RMDQ_SF
# Variáveis Binárias ----------------------------------------
bindata = Bin_Gut_BPI_RMDQ #(Oswestry e SF não tem binária)
#N?o há relação de ordinalidade, logo, todos os dados do dataset bindata são
#Se N?o adicionarmos [], R N?o mantém a estrutura de fatores
bindata[] = lapply(bindata[], factor)
#Primeira coluna é ind??ce, logo, podemos deletar
bindata[1] = NULL
View(ordinaldf)
View(bindata)
# Juntar as bases de de binarios e ordinais ------------------------------------------------
#Todas binárias até o momento
Bin_Gut_BPI_RMDQ = read.csv('indata/Bin_Got_BPI_RMDQ_FILTRADA.csv')
rm(list=ls())
# setwd('C:/Users/vitor/OneDrive - IPT/Lefort/Segmentacao1')
# setwd('C:/Users/vpb/OneDrive - IPT/Lefort/Segmentacao1')
setwd('C:/GD/DS/Lefort/APRESENTACAO_IBRAVS/APRESENTACAO_FINAL_IBRAVS_CORRELOGRAMA_REDUZIDO')
library(tidyverse)
library(GGally)
library(lattice)
# Objetivo deste código é conseguir visualizar correlações entre as variáveis cont??nuas, e entre as variáveis
# cont??nuas e variáveis binárias para as variáveis do questionário 1 e 2
# Juntar as bases de de binarios e ordinais ------------------------------------------------
#Todas binárias até o momento
Bin_Gut_BPI_RMDQ = read.csv('indata/Bin_Got_BPI_RMDQ_FILTRADA.csv', sep = ';')
#Ordinais até RMDQ
Ord_Gut_BPI_Oswestry_RMDQ = read.csv('indata/Ordinal_Q1_Q2_Q3_Q4_FILTRADA.csv', sep = ';')
Ord_Gut_BPI_Oswestry_RMDQ[c(1:2)] = NULL
#######################################################################################################
###BY PASS EM SF, NÃO PRECISA DESSE QUESTIONÁRIO SÓ PRA PLOTAR O QUE PRECISO PARA A APRESENTAÇÃO
#######################################################################################################
#Salvando todos ordinais até o momento:
Ord_Gut_BPI_Oswestry_RMDQ_SF = Ord_Gut_BPI_Oswestry_RMDQ
# write.csv(Ord_Gut_BPI_Oswestry_RMDQ_SF, 'outputdata/Ordinal_Gut_BPI_Oswestry_RMDQ_SF.csv')
#Binárias e ordinais até o momento
Binaria_Ordinal_Q1_Q2_Q3_Q4_Q5 = data.frame(cbind(Bin_Gut_BPI_RMDQ,Ord_Gut_BPI_Oswestry_RMDQ_SF))
# write.csv(Binaria_Ordinal_Q1_Q2_Q3_Q4_Q5, 'outputdata/Binaria_Ordinal_Q1_Q2_Q3_Q4_Q5.csv')
# Subset com as variáveis ordinais ----------------------------------------
ordinallist = names(Ord_Gut_BPI_Oswestry_RMDQ_SF)
ordinaldf = Ord_Gut_BPI_Oswestry_RMDQ_SF
# Variáveis Binárias ----------------------------------------
bindata = Bin_Gut_BPI_RMDQ #(Oswestry e SF não tem binária)
#N?o há relação de ordinalidade, logo, todos os dados do dataset bindata são
#Se N?o adicionarmos [], R N?o mantém a estrutura de fatores
bindata[] = lapply(bindata[], factor)
#Primeira coluna é ind??ce, logo, podemos deletar
bindata[1] = NULL
dfbind = cbind(ordinaldf,bindata)
#write.csv(dfbind,'binaria_e_ordinal.csv')
library(reshape2)
meltdata = melt(data = dfbind, id.vars = names(bindata), measure.vars = names(ordinaldf))
names(meltdata)
write.csv(meltdata, 'outputdata/meltdataboxsplot.csv')
#Dor na lombar
ggplot(data = meltdata, aes(D30,value)) +
geom_boxplot(aes(fill = D30)) +
geom_jitter(size = 0.5) +
facet_wrap(.~variable, scales = "free")
# Coeficiente de correlação de ponto bisserial ----------------------------
library(polycor)
polyserial(as.numeric(dfbind$Ord_RMDQ),dfbind$D35)
# # Matriz de correlação  ---------------------------------------------------
#
# rpb = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
# xaxis = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
# yaxis = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
# cont_Bin_0 = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
# cont_Bin_1 = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
# missing = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
#
# cont = 1
# for (j in 1:length(bindata)){
#   for (i in 1:length(ordinaldf)){
#
#     rpb[cont,] = polyserial(as.numeric(ordinaldf[[i]]), bindata[[j]])
#     xaxis[cont,] = names(ordinaldf[i])
#     yaxis[cont,] = names(bindata[j])
#
#     #Retornar contagem de valores zero e valores um da variável binária
#     #Isto é importante para saber quantos dados temos na correlação
#     #As vezes a correlação é grande só porque temos poucos dados
#     aux = data.frame(bin = bindata[[j]], ord = ordinaldf[[i]])
#     aux_ = aux[complete.cases(aux),]
#     tbl = table(aux_[[1]]) #Contar apenas o número de zeros e ones do binário, que é a primeira coluna
#     cont_Bin_0[cont,] = tbl[1] #Número de zeros
#     cont_Bin_1[cont,] = tbl[2] #Número de ones
#
#     #Ele retorna missing no boxplot se a pessoa respondeu a questão da ordinária, mas N?o respondeu a questão binária
#     missingord = aux[!is.na(aux[[2]]),] #O ??ndice 2 se refere à variável ordinal
#     missing[cont,] = sum(is.na(missingord[[1]])) #O ??ndice 1 se refere à variável binária, da qual deveremos contar os missing
#
#     cont = cont + 1
#   }
# }
#
# #Aqui finalmente é a matriz de correlação
# pbmatrix = data.frame(cbind(yaxis, xaxis, rpb, cont_Bin_0, cont_Bin_1, missing))
# names(pbmatrix) = c("Binaria","Ordinal","rpb","Bin_0","Bin_1","Missing")
#
# write.csv(pbmatrix, 'outputdata/biseralcorrelation_Q1_Q2_Q3_Q4_Q5_V2.csv')
#Matrix de correlação
corrmatrix = matrix(NA, nrow = length(bindata), ncol = length(ordinaldf))
#Criar matrix
for (j in 1:length(bindata)){
for (i in 1:length(ordinaldf)){
#Preencher a matriz
corrmatrix[j,i] = polyserial(as.numeric(ordinaldf[[i]]), bindata[[j]])
}
}
#Para obter a matrix de correlação
corrdf = data.frame(corrmatrix)
rownames(corrdf) = c(names(bindata))
colnames(corrdf) = names(ordinaldf)
library(corrplot)
tiff('outputdata/imgs/Binaria_Ordinal_CorrelationMatrix_Q12345.tiff', units = 'in', width = 12, height = 20, res = 450)
corrplot(as.matrix(corrdf),
tl.srt = 45,
tl.col = 'black',
title = "Matrix de correlação de ponto bisserial (correlograma) entre as variáveis binárias (linhas)
e variáveis ordinais (colunas) para os Questionários Gotemburgo, BPI, Oswestry, RMDQ e SF",
mar=c(0,0,3,0))
dev.off()
tiff('outputdata/imgs/Binaria_Ordinal_CorrelationMatrix_Number_q12345.tiff', units = 'in', width = 25, height = 35, res = 300)
corrplot(as.matrix(corrdf),
tl.srt = 45,
tl.col = 'black',
title = "Matrix de correlação de ponto bisserial (correlograma) entre as variáveis binárias (linhas)
e variáveis ordinais (colunas) para os Questionários Gotemburgo, BPI e Oswestry, RMDQ e SF",
mar=c(0,0,3,0),
method = 'number')
dev.off()
# # Mapa dos valores binários: ------------------------------------------------------
#
# cont_Bin_0 = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
# cont_Bin_1 = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
# missing = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
#
# #Matriz que irá receber os valores de missing
# bincontmatrix = matrix(NA, nrow = length(bindata), ncol = length(ordinaldf))
#
# cont = 1
# for (j in 1:length(bindata)){
#   for (i in 1:length(ordinaldf)){
#
#     #Retornar contagem de valores zero e valores um da variável binária
#     #Isto é importante para saber quantos dados temos na correlação
#     #As vezes a correlação é grande só porque temos poucos dados
#     aux = data.frame(bin = bindata[[j]], ord = ordinaldf[[i]])
#     aux_ = aux[complete.cases(aux),]
#     tbl = table(aux_[[1]]) #Contar apenas o número de zeros e ones do binário, que é a primeira coluna
#     cont_Bin_0 = tbl[1] #Número de zeros
#     cont_Bin_1 = tbl[2] #Número de ones
#
#     # #Ele retorna missing no boxplot se a pessoa respondeu a questão da ordinária, mas N?o respondeu a questão binária
#     # missingord = aux[!is.na(aux[[2]]),] #O ??ndice 2 se refere à variável ordinal
#     # missing[cont,] = sum(is.na(missingord[[1]])) #O ??ndice 1 se refere à variável binária, da qual deveremos contar os missing
#     #
#
#     values = paste(cont_Bin_0," | ",cont_Bin_1, sep = "")
#     #Preencher a matriz
#
#     bincontmatrix[j,i] = values
#
#     cont = cont + 1
#
#
#   }
# }
# corrdf_bin = data.frame(bincontmatrix)
#
# rownames(corrdf_bin) = c(names(bindata))
# colnames(corrdf_bin) = names(ordinaldf)
#
# #NA ESQUERDA FICAM OS ZEROS E NA DIREITA OS ONES
# #Save the dataframe as image
# library(gridExtra)
# tiff("outputdata/imgs/Binary_Biserial_Cont_0_1.png", units = "in", width=80 ,height=35 ,res = 150)
# grid.table(corrdf_bin)
# dev.off()
rm(list=ls())
# setwd('C:/Users/vitor/OneDrive - IPT/Lefort/Segmentacao1')
# setwd('C:/Users/vpb/OneDrive - IPT/Lefort/Segmentacao1')
setwd('C:/GD/DS/Lefort/APRESENTACAO_IBRAVS/APRESENTACAO_FINAL_IBRAVS_CORRELOGRAMA_REDUZIDO')
library(tidyverse)
library(GGally)
library(lattice)
# Objetivo deste código é conseguir visualizar correlações entre as variáveis cont??nuas, e entre as variáveis
# cont??nuas e variáveis binárias para as variáveis do questionário 1 e 2
# Juntar as bases de de binarios e ordinais ------------------------------------------------
#Todas binárias até o momento
Bin_Gut_BPI_RMDQ = read.csv('indata/Bin_Got_BPI_RMDQ_FILTRADA.csv', sep = ';')
#Ordinais até RMDQ
Ord_Gut_BPI_Oswestry_RMDQ = read.csv('indata/Ordinal_Q1_Q2_Q3_Q4_FILTRADA.csv', sep = ';')
Ord_Gut_BPI_Oswestry_RMDQ[c(1:2)] = NULL
#######################################################################################################
###BY PASS EM SF, NÃO PRECISA DESSE QUESTIONÁRIO SÓ PRA PLOTAR O QUE PRECISO PARA A APRESENTAÇÃO
#######################################################################################################
#Salvando todos ordinais até o momento:
Ord_Gut_BPI_Oswestry_RMDQ_SF = Ord_Gut_BPI_Oswestry_RMDQ
# write.csv(Ord_Gut_BPI_Oswestry_RMDQ_SF, 'outputdata/Ordinal_Gut_BPI_Oswestry_RMDQ_SF.csv')
#Binárias e ordinais até o momento
Binaria_Ordinal_Q1_Q2_Q3_Q4_Q5 = data.frame(cbind(Bin_Gut_BPI_RMDQ,Ord_Gut_BPI_Oswestry_RMDQ_SF))
# write.csv(Binaria_Ordinal_Q1_Q2_Q3_Q4_Q5, 'outputdata/Binaria_Ordinal_Q1_Q2_Q3_Q4_Q5.csv')
# Subset com as variáveis ordinais ----------------------------------------
ordinallist = names(Ord_Gut_BPI_Oswestry_RMDQ_SF)
ordinaldf = Ord_Gut_BPI_Oswestry_RMDQ_SF
# Variáveis Binárias ----------------------------------------
bindata = Bin_Gut_BPI_RMDQ #(Oswestry e SF não tem binária)
#N?o há relação de ordinalidade, logo, todos os dados do dataset bindata são
#Se N?o adicionarmos [], R N?o mantém a estrutura de fatores
bindata[] = lapply(bindata[], factor)
#Primeira coluna é ind??ce, logo, podemos deletar
bindata[1] = NULL
dfbind = cbind(ordinaldf,bindata)
#write.csv(dfbind,'binaria_e_ordinal.csv')
library(reshape2)
meltdata = melt(data = dfbind, id.vars = names(bindata), measure.vars = names(ordinaldf))
names(meltdata)
write.csv(meltdata, 'outputdata/meltdataboxsplot.csv')
#Dor na lombar
ggplot(data = meltdata, aes(D30,value)) +
geom_boxplot(aes(fill = D30)) +
geom_jitter(size = 0.5) +
facet_wrap(.~variable, scales = "free")
# Coeficiente de correlação de ponto bisserial ----------------------------
library(polycor)
polyserial(as.numeric(dfbind$Ord_RMDQ),dfbind$D35)
# # Matriz de correlação  ---------------------------------------------------
#
# rpb = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
# xaxis = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
# yaxis = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
# cont_Bin_0 = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
# cont_Bin_1 = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
# missing = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
#
# cont = 1
# for (j in 1:length(bindata)){
#   for (i in 1:length(ordinaldf)){
#
#     rpb[cont,] = polyserial(as.numeric(ordinaldf[[i]]), bindata[[j]])
#     xaxis[cont,] = names(ordinaldf[i])
#     yaxis[cont,] = names(bindata[j])
#
#     #Retornar contagem de valores zero e valores um da variável binária
#     #Isto é importante para saber quantos dados temos na correlação
#     #As vezes a correlação é grande só porque temos poucos dados
#     aux = data.frame(bin = bindata[[j]], ord = ordinaldf[[i]])
#     aux_ = aux[complete.cases(aux),]
#     tbl = table(aux_[[1]]) #Contar apenas o número de zeros e ones do binário, que é a primeira coluna
#     cont_Bin_0[cont,] = tbl[1] #Número de zeros
#     cont_Bin_1[cont,] = tbl[2] #Número de ones
#
#     #Ele retorna missing no boxplot se a pessoa respondeu a questão da ordinária, mas N?o respondeu a questão binária
#     missingord = aux[!is.na(aux[[2]]),] #O ??ndice 2 se refere à variável ordinal
#     missing[cont,] = sum(is.na(missingord[[1]])) #O ??ndice 1 se refere à variável binária, da qual deveremos contar os missing
#
#     cont = cont + 1
#   }
# }
#
# #Aqui finalmente é a matriz de correlação
# pbmatrix = data.frame(cbind(yaxis, xaxis, rpb, cont_Bin_0, cont_Bin_1, missing))
# names(pbmatrix) = c("Binaria","Ordinal","rpb","Bin_0","Bin_1","Missing")
#
# write.csv(pbmatrix, 'outputdata/biseralcorrelation_Q1_Q2_Q3_Q4_Q5_V2.csv')
#Matrix de correlação
corrmatrix = matrix(NA, nrow = length(bindata), ncol = length(ordinaldf))
#Criar matrix
for (j in 1:length(bindata)){
for (i in 1:length(ordinaldf)){
#Preencher a matriz
corrmatrix[j,i] = polyserial(as.numeric(ordinaldf[[i]]), bindata[[j]])
}
}
#Para obter a matrix de correlação
corrdf = data.frame(corrmatrix)
rownames(corrdf) = c(names(bindata))
colnames(corrdf) = names(ordinaldf)
library(corrplot)
tiff('outputdata/imgs/Binaria_Ordinal_CorrelationMatrix_Q12345.tiff',
units = 'in', width = 6, height = 10, res = 300)
corrplot(as.matrix(corrdf),
tl.srt = 45,
tl.col = 'black',
title = "Matrix de correlação de ponto bisserial (correlograma) entre as variáveis binárias (linhas)
e variáveis ordinais (colunas) para os Questionários Gotemburgo, BPI, Oswestry, RMDQ e SF",
mar=c(0,0,3,0))
dev.off()
tiff('outputdata/imgs/Binaria_Ordinal_CorrelationMatrix_Number_q12345.tiff',
units = 'in', width = 6, height = 10, res = 300)
corrplot(as.matrix(corrdf),
tl.srt = 45,
tl.col = 'black',
title = "Matrix de correlação de ponto bisserial (correlograma) entre as variáveis binárias (linhas)
e variáveis ordinais (colunas) para os Questionários Gotemburgo, BPI e Oswestry, RMDQ e SF",
mar=c(0,0,3,0),
method = 'number')
dev.off()
# # Mapa dos valores binários: ------------------------------------------------------
#
# cont_Bin_0 = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
# cont_Bin_1 = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
# missing = matrix(NA, nrow = length(ordinaldf)*length(bindata), ncol = 1)
#
# #Matriz que irá receber os valores de missing
# bincontmatrix = matrix(NA, nrow = length(bindata), ncol = length(ordinaldf))
#
# cont = 1
# for (j in 1:length(bindata)){
#   for (i in 1:length(ordinaldf)){
#
#     #Retornar contagem de valores zero e valores um da variável binária
#     #Isto é importante para saber quantos dados temos na correlação
#     #As vezes a correlação é grande só porque temos poucos dados
#     aux = data.frame(bin = bindata[[j]], ord = ordinaldf[[i]])
#     aux_ = aux[complete.cases(aux),]
#     tbl = table(aux_[[1]]) #Contar apenas o número de zeros e ones do binário, que é a primeira coluna
#     cont_Bin_0 = tbl[1] #Número de zeros
#     cont_Bin_1 = tbl[2] #Número de ones
#
#     # #Ele retorna missing no boxplot se a pessoa respondeu a questão da ordinária, mas N?o respondeu a questão binária
#     # missingord = aux[!is.na(aux[[2]]),] #O ??ndice 2 se refere à variável ordinal
#     # missing[cont,] = sum(is.na(missingord[[1]])) #O ??ndice 1 se refere à variável binária, da qual deveremos contar os missing
#     #
#
#     values = paste(cont_Bin_0," | ",cont_Bin_1, sep = "")
#     #Preencher a matriz
#
#     bincontmatrix[j,i] = values
#
#     cont = cont + 1
#
#
#   }
# }
# corrdf_bin = data.frame(bincontmatrix)
#
# rownames(corrdf_bin) = c(names(bindata))
# colnames(corrdf_bin) = names(ordinaldf)
#
# #NA ESQUERDA FICAM OS ZEROS E NA DIREITA OS ONES
# #Save the dataframe as image
# library(gridExtra)
# tiff("outputdata/imgs/Binary_Biserial_Cont_0_1.png", units = "in", width=80 ,height=35 ,res = 150)
# grid.table(corrdf_bin)
# dev.off()
tiff('outputdata/imgs/Binaria_Ordinal_CorrelationMatrix_Number_q12345.tiff',
units = 'in', width = 8, height = 12, res = 300)
corrplot(as.matrix(corrdf),
tl.srt = 45,
tl.col = 'black',
title = "Matrix de correlação de ponto bisserial (correlograma) entre as variáveis binárias (linhas)
e variáveis ordinais (colunas) para os Questionários Gotemburgo, BPI e Oswestry, RMDQ e SF",
mar=c(0,0,3,0),
method = 'number')
dev.off()
